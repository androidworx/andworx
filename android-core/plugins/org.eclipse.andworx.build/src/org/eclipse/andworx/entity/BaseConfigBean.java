/*
 * Copyright (C) 2018 The Android Open Source Project
 *
 * Licensed under the Eclipse Public License, Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.eclipse.org/org/documents/epl-v10.php
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.eclipse.andworx.entity;

//import static com.android.builder.core.BuilderConstants.DEBUG;
//import static com.android.builder.core.BuilderConstants.RELEASE;

import java.io.File;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.FetchType;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.OneToMany;
import javax.persistence.OneToOne;

import org.eclipse.andworx.model.FieldName;

import com.android.builder.model.AndroidArtifact;
import com.android.builder.model.BaseConfig;
import com.android.builder.model.ClassField;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableMap.Builder;

/*
 * Implements BaseConfig inerface shared by Build Type and Product flavor.
 */
@Entity(name="tableBaseConfig")
public class BaseConfigBean implements BaseConfig {

	/** We use this field-name so we can query for projects with a certain id */
	public final static String ID_FIELD_NAME = "id";
    /** Column name in join table for project foreign key */
	public final static String PROJECT_ID_FIELD_NAME = "project_id";

	private final static String BLANK = "";
	
	/** This id is generated by the database and set on the object when it is passed to the create method */
    @Id @GeneratedValue
 	int id;

	/** This is a foreign object which just stores the id from the Project object in this table. */
    @OneToOne
    @JoinColumn(name=PROJECT_ID_FIELD_NAME, referencedColumnName="id")
	ProjectBean projectBean;

	/** ClassFields belonging to this base config. The association is uni-directional, and the base config "owns" it */
    @OneToMany(fetch=FetchType.EAGER)
    Collection<ClassFieldBean> classFieldBeans;
 
	/** BaseStrings belonging to this base config. The association is uni-directional, and the base config "owns" it */
    @OneToMany(fetch=FetchType.EAGER)
    Collection<BaseString> baseStrings;
 
	@Column
	String name;
	@Column
	String applicationIdSuffix;
	@Column
	String versionNameSuffix;
	@Column
	String multiDexKeepFile;
	@Column
	String multiDexKeepProguard;
	@Column
    Boolean multiDexEnabled;
	// TDOD - manifestPlaceholders
	Map<String, Object> manifestPlaceholders;
	
    /**
     * Construct BuildTypeEntity object
     */
	public BaseConfigBean(String name) {
		this();
		this.name = name;
		applicationIdSuffix = BLANK;
		versionNameSuffix = BLANK;
		classFieldBeans = Collections.emptyList();
	}

    /**
     * BuildTypeEntity default constructor for OrmLite
     */
	BaseConfigBean() 
	{
		manifestPlaceholders = new HashMap<>();
	}

	public void setProjectBean(ProjectBean projectBean) {
		this.projectBean = projectBean;
	}

	public void setApplicationIdSuffix(String applicationIdSuffix) {
		this.applicationIdSuffix = applicationIdSuffix;
	}

	public void setVersionNameSuffix(String versionNameSuffix) {
		this.versionNameSuffix = versionNameSuffix;
	}

	public void setManifestPlaceholders(Map<String, Object> manifestPlaceholders) {
		this.manifestPlaceholders = manifestPlaceholders;
	}

	public void setMultiDexKeepFile(String multiDexKeepFile) {
		this.multiDexKeepFile = multiDexKeepFile;
	}

	public void setMultiDexKeepProguard(String multiDexKeepProguard) {
		this.multiDexKeepProguard = multiDexKeepProguard;
	}

	public void setMultiDexEnabled(Boolean multiDexEnabled) {
		this.multiDexEnabled = multiDexEnabled;
	}

	/**
	 * Build type name 
	 * There are two Standard Build Types defined in com.android.builder.core.BuilderConstants: DEBUG and RELEASE
	 */
	@Override
	public String getName() {
		return name;
	}

    /**
     * Optional
     * Returns the application id suffix applied to this base config. eg. ".free", ".pro", ".debug", ".release"
     * To get the final application id, use {@link AndroidArtifact#getApplicationId()}.
     * Reference: https://developer.android.com/studio/build/application-id
     * Code reference: DefaultProductFlavor class
     * @return the application id suffix or empty String if none is configured
     */
	@Override
	public String getApplicationIdSuffix() {
		return applicationIdSuffix;
	}

    /**
     * Optional
     * Returns the version name suffix applied to this base config. eg. "-demo", "-full"
     * Reference: https://developer.android.com/studio/build/build-variants
     * Code reference: DefaultProductFlavor class
     * @return the version name suffix or empty String if none is configured
     */
	@Override
	public String getVersionNameSuffix() {
		return versionNameSuffix;
	}

    /**
     * Map of Build Config Fields where the key is the field name.
     * Reference: https://developer.android.com/studio/build/gradle-tips "Share custom fields and resource values with your app's code"
     *
     * @return a non-null map of class fields (possibly empty).
     */
	@Override
	public Map<String, ClassField> getBuildConfigFields() {
		return getClassFieldMap(FieldName.buildConfigField);
	}

    /**
     * Map of generated res values where the key is the res name.
     *
     * @return a non-null map of class fields (possibly empty).
     */
	@Override
	public Map<String, ClassField> getResValues() {
		return getClassFieldMap(FieldName.resField);
	}

    /**
     * Specifies the ProGuard configuration files that the plugin should use.
     *
     * <p>There are two ProGuard rules files that ship with the Android plugin and are used by
     * default:
     *
     * <ul>
     *   <li>proguard-android.txt
     *   <li>proguard-android-optimize.txt
     * </ul>
     *
     * <p><code>proguard-android-optimize.txt</code> is identical to <code>proguard-android.txt
     * </code>, exccept with optimizations enabled. You can use <code>
     * getDefaultProguardFile(String filename)</code> to return the full path of the files.
     *
     * @return a non-null collection of files.
     * @see #getTestProguardFiles()
     */
	@Override
	public Collection<File> getProguardFiles() {
		com.google.common.collect.ImmutableList.Builder<File> builder = ImmutableList.builder();
		for (BaseString string: baseStrings)
			if (string.fieldName == FieldName.proguardFile)
				builder.add(new File(string.getValue()));
		return builder.build();
	}

    /**
     * Returns the collection of proguard rule files for consumers of the library to use.
     *
     * @return a non-null collection of files.
     */
	@Override
	public Collection<File> getConsumerProguardFiles() {
		com.google.common.collect.ImmutableList.Builder<File> builder = ImmutableList.builder();
		for (BaseString string: baseStrings)
			if (string.fieldName == FieldName.consumerProguardFile)
				builder.add(new File(string.getValue()));
		return builder.build();
	}

    /**
     * Returns the collection of proguard rule files to use for the test APK.
     *
     * @return a non-null collection of files.
     */
	@Override
	public Collection<File> getTestProguardFiles() {
		com.google.common.collect.ImmutableList.Builder<File> builder = ImmutableList.builder();
		for (BaseString string: baseStrings)
			if (string.fieldName == FieldName.testProguardFile)
				builder.add(new File(string.getValue()));
		return builder.build();
	}

    /**
     * Returns the map of key value pairs for placeholder substitution in the android manifest file.
     *
     * This map will be used by the manifest merger.
     * @return the map of key value pairs.
     */
	@Override
	public Map<String, Object> getManifestPlaceholders() {
		return manifestPlaceholders;
	}

    /**
     * Optional
     * Returns whether multi-dex is enabled.
     *
     * This can be null if the flag is not set, in which case the default value is used.
     */
	@Override
	public Boolean getMultiDexEnabled() {
		return multiDexEnabled;
	}

	/**
	 * Optional
	 *  File which specifies additional classes required to be included in the primary DEX file
	 *  Reference: https://developer.android.com/studio/build/multidex
	 */
	@Override
	public File getMultiDexKeepFile() {
		return new File(multiDexKeepFile);
	}

	/**
	 * Optional
	 * Alternative to multiDexKeepFile 
	 */
	@Override
	public File getMultiDexKeepProguard() {
		return new File(multiDexKeepProguard);
	}

	private Map<String, ClassField> getClassFieldMap(FieldName fieldName) {
		Builder<String, ClassField> builder = ImmutableMap.builder();
		for (ClassFieldBean bean: classFieldBeans)
			if (bean.getFieldName().equals(fieldName))
				builder.put(bean.getName(), bean);
		return builder.build();
	}
}
